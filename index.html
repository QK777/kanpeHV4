<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FF14 カンペ</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600..800&family=Inter:wght@400..800&display=swap" rel="stylesheet">
  <style>
    /* =========================================================
       EDIT HERE（後で調整しやすいCSS変数）
========================================================= */
    :root{
      --left-reset-h: 96px; /* 左リセット固定高さ */
      --bg0:#060810;
      --bg1:#0B1020;
      --card: rgba(18, 20, 32, 0.72);
      --card2: rgba(10, 12, 22, 0.70);
      --border: rgba(180, 205, 255, 0.18);
      --border2: rgba(180, 205, 255, 0.10);
      --text: rgba(240, 248, 255, 0.92);
      --muted: rgba(240, 248, 255, 0.60);
      --shadow: 0 20px 54px rgba(0,0,0,0.60);

      --radius: 18px;
      --radius2: 14px;

      --btnBg: rgba(255,255,255,0.10);
      --btnBgHover: rgba(255,255,255,0.14);
      --btnActive: rgba(120, 200, 255, 0.22);
      --btnBorder: rgba(180, 205, 255, 0.20);

      /* 画像表示はすべて contain */
      --cross-scale: 1.00; /* ← 大きくしたいなら 1.05 などに（上げると見切れやすいので注意） */
      --ougi-scale: 0.75;  /* ← 安地画像スケール（75%） */

      /* 枠サイズ（一定） */
      --cross-frame-h: clamp(150px, 18vw, 220px);
      --ougi-frame-h:  clamp(150px, 18vw, 220px);
      --marker-row-h: clamp(56px, 6.2vw, 74px);
      --marker-frame-h: var(--marker-row-h);

      /* マーカーボード */
      --board-size: clamp(260px, 36vw, 420px);
      --mk-size: clamp(45.8px, 6.51vw, 73.0px); /* 10% back from v10 */

      /* タップしやすさ */
      --tap: 42px;

      /* ← 大円/小円の文字サイズ */
      --kind-label-size: 22px;  

      /* kind pill label font */
      --kind-label-font: "Fraunces", "Shippori Mincho", "Noto Serif JP", system-ui, sans-serif;

      /* kind pill icon size */
      --kind-icon: clamp(30px, 3.4vw, 42px);
      --kind-pill-minh: var(--marker-row-h);
      --kind-label-color: rgba(240,245,255,.92); /* ← 文字色 */
      --kind-label-muted: rgba(240,245,255,.72); /* ← サブ/薄い場合 */

      /* マーカー（大円/頭割） 左カードの幅（ここを縮めると縦が詰まりやすい） */
      --kind-col-w: 96px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(110,165,255,0.20), transparent 60%),
        radial-gradient(900px 500px at 72% 8%, rgba(140,90,255,0.16), transparent 62%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    .app{ max-width: 1280px; margin: 0 auto; padding: 16px; }
    /* ===== Layout（画像のように：左=操作/ボード、右=表示） ===== */
    .layout{
      display:grid;
      grid-template-columns: 420px 1fr;
      gap: 16px;
      align-items:start;
    }

    /* 1100px以下：少し細く */
    @media (max-width: 1100px){
      .layout{ grid-template-columns: 360px 1fr; }
    }

    /* iPad縦あたり：さらに細く（でも2カラム維持） */
    @media (max-width: 860px){
      .layout{ grid-template-columns: 320px 1fr; gap: 12px; }
    }

    /* 大きめスマホ：左をさらに圧縮（2カラム維持） */
    @media (max-width: 760px){
      .layout{ grid-template-columns: 290px 1fr; gap: 10px; }
      :root{
      --left-reset-h: 96px; /* 左リセット固定高さ */ --kind-col-w: 96px; }
    }

    /* 小さめスマホ：比率で割る（2カラム維持） */
    @media (max-width: 560px){
      .layout{ grid-template-columns: 44vw 56vw; gap: 6px; }
      .app{ padding: 10px; }
      :root{
      --left-reset-h: 96px; /* 左リセット固定高さ */
        --tap: 42px;
        --kind-icon: clamp(46px, 5.0vw, 64px);
        --kind-pill-minh: var(--marker-row-h);
        --board-size: min(240px, 44vw);
        --kind-col-w: 96px;
      }
    }

    .panel{
      background: linear-gradient(180deg, var(--card), var(--card2));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    /* left panel layout */
    aside.panel{display:grid; grid-template-rows: 1fr auto; position:relative;}

    \.reset-wrap{position:relative; height: var(--left-reset-h); padding: 10px 14px 12px; display:flex; flex-direction:column; gap:8px; align-items:center; justify-content:center; border-top: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.18); backdrop-filter: blur(8px);}
    /* .btn の後に来ても負けないよう、.btn.btn-reset で上書き */
    .btn.btn-reset{ background: rgba(255,90,120,0.14); border-color: rgba(255,140,160,0.35); }
    .btn.btn-reset:hover{ background: rgba(255,90,120,0.18); }
    .reset-hint{ font-size:12px; color: var(--muted); text-align:center; }

    .divider{ height:1px; background: rgba(255,255,255,0.10); margin: 14px 14px; }

/* ===== Left panel: reorderable control blocks ===== */
.left-stack{display:flex; flex-direction:column; padding: 10px 0 0 0; flex:1; overflow:auto; padding-bottom: 10px;}
.left-unit{ position:relative; }
.left-unit:not(:first-child){ border-top: 1px solid rgba(255,255,255,0.10); }
.left-unit .left-handle{
  position:absolute;
  top: 10px;
  right: 10px;
  width: 34px;
  height: 34px;
  border-radius: 10px;
  display:flex;
  align-items:center;
  justify-content:center;
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(180,205,255,0.18);
  color: rgba(240,248,255,0.85);
  cursor: grab;
  touch-action: none;
  user-select:none;
  z-index: 2;
}
.left-unit .left-handle:active{ cursor: grabbing; }
.left-unit.is-drop-hint{ outline: 2px solid rgba(120,200,255,0.45); outline-offset: -2px; }
    /* ===== Left controls (＋字/×字, 安地) ===== */
    .left-controls{ padding: 14px; }
    .left-controls .btn-col{
      display:flex;
      flex-direction:column;
      gap: 12px;
      align-items:center;
    }

    .btn{
      min-height: var(--tap);
      height: var(--tap);
      width: min(260px, 100%);
      padding: 0 16px;
      border-radius: 14px;
      border: 1px solid var(--btnBorder);
      background: var(--btnBg);
      color: var(--text);
      cursor:pointer;
      font-weight: 780;
      letter-spacing: 0.3px;
      user-select:none;
      touch-action: manipulation;
      transition: background .12s ease, transform .08s ease, border-color .12s ease;
    }
    .btn:hover{ background: var(--btnBgHover); }
    .btn:active{ transform: scale(0.985); }
    .btn.is-active{ background: rgba(120,200,255,0.20); border-color: rgba(120,200,255,0.55); }

    /* ===== Marker board (t1風に戻す) ===== */
    .board-wrap{ padding: 14px; }
    /* ===== Meteor (隕石) ===== */
    .meteor-wrap{ padding: 10px; }
    .meteor-strip{
      display:flex;
      gap: 10px;
      justify-content: center;
      align-items: center;
      flex-wrap: nowrap;
    }
    .meteor-btn{
      width: 72px;
      height: 72px;
      border-radius: 14px;
      border: 1px solid rgba(180,205,255,0.18);
      background: rgba(255,255,255,0.06);
      box-shadow: 0 14px 34px rgba(0,0,0,0.55);
      cursor:pointer;
      padding: 6px;
      display:flex;
      align-items:center;
      justify-content:center;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
      touch-action: manipulation;
    }
    .meteor-btn:hover{ background: rgba(255,255,255,0.10); }
    .meteor-btn:active{ transform: scale(0.985); }
    .meteor-btn.is-active{
      border-color: rgba(120,200,255,0.62);
      background: rgba(120,200,255,0.16);
      outline: 3px solid rgba(255,255,255,0.22);
      outline-offset: 2px;
    }
    .meteor-btn img{
      width: 100%;
      height: 100%;
      object-fit: contain;
      display:block;
      filter: drop-shadow(0 8px 18px rgba(0,0,0,0.45));
    }

    /* ===== Meteor result frame ===== */
    .meteor-frame{ height: clamp(105px, 12vw, 150px); }
    .meteor-inner{
      position:relative;
      height:100%;
      display:flex;
      gap: 16px;
      align-items:center;
      padding: 14px 16px;
    }
    .meteor-frame.placeholder .meteor-inner{ opacity: 0; }
    .meteor-result-img{
      width: clamp(118px, 10vw, 160px);
      height: clamp(118px, 10vw, 160px);
      border-radius: 0;
      background: transparent;
      border: none;
      box-shadow: none;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0;
      flex: 0 0 auto;
    }
    .meteor-result-img img{
      width:100%;
      height:100%;
      object-fit: contain;
      display:block;
    }
    .meteor-text{
      min-width: 0;
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .meteor-title{
      font-weight: 820;
      letter-spacing: .2px;
      color: rgba(240,248,255,0.92);
      font-size: 14px;
    }
    .meteor-lines{
      color: rgba(240,248,255,0.82);
      font-weight: 760;
      line-height: 1.35;
      font-size: 13px;
      white-space: pre-line;
    }

    .board-caption{ color: var(--muted); font-size: 12px; margin-bottom: 10px; }

    .marker-board{
      width: var(--board-size);
      height: var(--board-size);
      max-width: 100%;
      border-radius: 22px;
      background:
        radial-gradient(900px 900px at 30% 20%, rgba(120,200,255,0.10), transparent 55%),
        radial-gradient(700px 700px at 70% 70%, rgba(170,120,255,0.10), transparent 58%),
        rgba(0,0,0,0.42);
      border: 1px solid rgba(180,205,255,0.18);
      box-shadow: 0 18px 50px rgba(0,0,0,0.62);
      position: relative;
      margin: 0 auto;
      overflow:hidden;
    }

    .mk{
      position:absolute;
      width: var(--mk-size);
      height: var(--mk-size);
      border: 3px solid rgba(0,0,0,0.70);
      box-shadow: 0 10px 22px rgba(0,0,0,0.55);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      transform: translate(-50%,-50%);
      color: rgba(0,0,0,0.88);
      font-weight: 900;
      font-size: clamp(18px, 3.5vw, 30px);
      letter-spacing: 0.5px;
    }

    .mk.is-active{
      outline: 4px solid rgba(255,255,255,0.92);
      outline-offset: 4px;
      box-shadow: 0 0 0 10px rgba(255,255,255,0.15), 0 16px 28px rgba(0,0,0,0.58);
    }

    /* shapes */
    .mk.square{ border-radius: 11px; }
    .mk.circle{ border-radius: 999px; }

    /* colors */
    .c-pink{ background:#FF9FA7; }
    .c-yellow{ background:#FFF3A6; }
    .c-blue{ background:#93D7FF; }
    .c-purple{ background:#C7B3FF; }

    /* positions (t1の見た目に寄せた％配置) */
    .mk-1{ left: 25%; top: 25%; }
    .mk-A{ left: 50%; top: 15%; }
    .mk-2{ left: 75%; top: 25%; }

    .mk-D{ left: 15%; top: 47%; }
    .mk-B{ left: 85%; top: 47%; }

    .mk-4{ left: 25%; top: 70%; }
    .mk-C{ left: 50%; top: 85%; }
    .mk-3{ left: 75%; top: 70%; }

    /* ===== Right: Display sections (ドラッグ並び替え/非表示) ===== */
    .stack{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      align-content:start;
    }
    .stack .section[data-span="2"]{ grid-column: 1 / -1; }
    @media (max-width: 700px){
      .stack{ grid-template-columns: 1fr; }
      .stack .section{ grid-column: auto; }
    }

    .section{
      min-width: 0;
      background: linear-gradient(180deg, rgba(18,20,32,0.65), rgba(10,12,22,0.62));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .section-header{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      user-select:none;
    }

    .drag-handle{
      width: 34px;
      height: 34px;
      border-radius: 10px;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(180,205,255,0.18);
      color: rgba(240,248,255,0.85);
      cursor: grab;
      touch-action: none;
    }
    .drag-handle:active{ cursor: grabbing; }

    .section-title{ flex:1; font-weight: 820; font-size: 14px; letter-spacing: 0.2px; }

    .icon-btn{
      height: 34px;
      border-radius: 10px;
      border: 1px solid rgba(180,205,255,0.18);
      background: rgba(255,255,255,0.08);
      color: rgba(240,248,255,0.92);
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      padding: 0 10px;
      font-size: 12px;
      font-weight: 760;
      transition: background .12s ease, transform .08s ease;
    }
    .icon-btn:hover{ background: rgba(255,255,255,0.12); }
    .icon-btn:active{ transform: scale(0.98); }
    .icon-btn.is-on{ background: rgba(120,200,255,0.18); border-color: rgba(120,200,255,0.55); }

    .section-body{ padding: 8px; }

    /* section content layout: 左=ボタン、右=表示枠（画像のように） */
    .row{
      display:grid;
      grid-template-columns: 280px 1fr;
      gap: 14px;
      align-items: stretch;
    }
    @media (max-width: 860px){
      .row{ grid-template-columns: 1fr; }
    }

    .row-left{
      display:flex;
      flex-direction:column;
      gap: 8px;
      align-items:center;
      justify-content:center;
      padding: 2px 0;
    }

    .frame{
      position:relative;
      width:100%;
      border-radius: var(--radius2);
      border: 1px solid rgba(180,205,255,0.16);
      background: rgba(0,0,0,0.35);
      overflow:hidden;
    }



/* ===== Ougi + Meteor 2カラム ===== */
.ougi-meteor-grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  align-items: stretch;
}
.ougi-meteor-grid .frame{ height: var(--ougi-frame-h); }
@media (max-width: 920px){
  .ougi-meteor-grid{ grid-template-columns: 1fr; }
  .ougi-meteor-grid .frame{ height: var(--ougi-frame-h); }
}

/* ===== Free layout controls ===== */
.layout-bar{
  grid-column: 1 / -1;
  display:flex;
  gap: 8px;
  padding: 8px 10px 0 10px;
  margin-bottom: 6px;
}
.layout-btn{
  height: 34px;
  padding: 0 12px;
  border-radius: 999px;
  border: 1px solid rgba(180,205,255,0.22);
  background: rgba(255,255,255,0.06);
  color: rgba(240,248,255,0.90);
  font-weight: 820;
  letter-spacing: .2px;
  cursor:pointer;
  user-select:none;
  touch-action: manipulation;
  box-shadow: 0 10px 24px rgba(0,0,0,0.35);
}
.layout-btn:hover{ background: rgba(255,255,255,0.10); }
.layout-btn.is-on{ background: rgba(120, 200, 255, 0.18); border-color: rgba(120,200,255,0.35); }

/* ===== iPhone-like toggle (配置モード) ===== */
.mode-switch{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 0 10px 0 14px;
  height: 38px;
  border-radius: 999px;
  border: 1px solid rgba(180,205,255,0.22);
  background: rgba(255,255,255,0.06);
  color: rgba(240,248,255,0.92);
  font-weight: 820;
  letter-spacing: .2px;
  cursor: pointer;
  user-select: none;
  touch-action: manipulation;
  box-shadow: 0 10px 24px rgba(0,0,0,0.35);
}
.mode-switch .mode-label{
  font-family: var(--kind-label-font);
  font-size: 14px;
}
.mode-switch .mode-state{
  font-size: 12px;
  color: rgba(240,248,255,0.70);
}
.mode-track{
  margin-left: 4px;
  width: 54px;
  height: 28px;
  border-radius: 999px;
  background: rgba(255,255,255,0.10);
  border: 1px solid rgba(180,205,255,0.18);
  position: relative;
  flex: 0 0 auto;
  transition: background .22s ease, border-color .22s ease;
}
.mode-thumb{
  width: 24px;
  height: 24px;
  border-radius: 999px;
  background: rgba(240,248,255,0.92);
  position: absolute;
  top: 1px;
  left: 2px;
  box-shadow: 0 12px 26px rgba(0,0,0,0.45);
  transition: transform .22s ease, background .22s ease;
}
.mode-switch.is-on .mode-track{
  background: rgba(75, 230, 160, 0.22);
  border-color: rgba(75,230,160,0.38);
}
.mode-switch.is-on .mode-thumb{
  transform: translateX(24px);
  background: rgba(240,255,250,0.96);
}


/* 自由配置モード：セクションを絶対配置 */
.stack.free-layout{ position: relative; overflow: auto; min-height: calc(100vh - 140px); padding-bottom: 240px; }
.stack.free-layout .section{ position:absolute; }
.stack.free-layout .section[data-span="2"]{ }
.stack.free-layout .section .drag-handle{ cursor: grab; }


    .frame.placeholder::after{
      content: attr(data-placeholder);
      position:absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 10px;
      text-align:center;
      color: rgba(240,248,255,0.52);
      font-weight: 760;
      letter-spacing: 0.2px;
      font-size: 12px;
    }

    .frame img{
      width:100%;
      height:100%;
      display:block;
      object-fit: contain;
      transform-origin:center;
    }

    /* 画像スケール（基本1.0 / contain） */
    .frame.cross img{ transform: scale(var(--cross-scale)); }
    .frame.ougi img{ transform: scale(var(--ougi-scale)); }

    /* Marker display rows（大円/頭割：左にカード、右に枠） */
    .marker-rows{ display:flex; flex-direction:column; gap: 10px; }

    .marker-row{
      display:grid;
      grid-template-columns: var(--kind-col-w) 1fr;
      gap: 10px;
      align-items: stretch;
      height: var(--marker-row-h);
    }
    @media (max-width: 480px){
      .marker-row{ grid-template-columns: 1fr; }
    }

    .kind-pill{
      border-radius: 16px;
      border: 1px solid rgba(180,205,255,0.16);
      background: rgba(255,255,255,0.08);
      padding: 6px;
      height: 100%;
      min-height: 0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap: 6px;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .kind-pill:hover{ background: rgba(255,255,255,0.12); }
    .kind-pill:active{ transform: scale(0.985); }
    .kind-pill.is-on{ background: rgba(120,200,255,0.18); border-color: rgba(120,200,255,0.55); }

    .kind-pill .t{
      color: #fff;
      font-size: 18px;             /* 20px */
      font-family: var(--kind-label-font);
      font-weight: 700;
      letter-spacing: 0.4px;
      text-shadow: 0 6px 16px rgba(0,0,0,0.55);
    }

    .kind-pill img{ width: var(--kind-icon); height: var(--kind-icon); max-width: 100%; max-height: 100%; object-fit: contain; filter: drop-shadow(0 10px 16px rgba(0,0,0,0.55)); }

    .marker-frame{ height: 100%; }

    /* 非選択側を隠す（枠サイズ維持） */
    .marker-row.is-muted{ opacity: 0; pointer-events:none; user-select:none; transform: scale(0.99); }
    .marker-row{ transition: opacity .12s ease, transform .12s ease; }

    /* Result label (押したボタン名を表示) */
    .result-label{
      position:absolute;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(180,205,255,0.18);
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      color: rgba(240,248,255,0.92);
      font-weight: 900;
      letter-spacing: 0.3px;
      font-size: 14px;
      pointer-events:none;
      box-shadow: 0 10px 22px rgba(0,0,0,0.55);
    }
    .result-label.is-empty{ display:none; }

    /* collapse */
    .section.is-collapsed .section-body{ display:none; }

    /* drag */
    .section.is-dragging{ outline: 2px solid rgba(120,200,255,0.55); box-shadow: 0 24px 64px rgba(0,0,0,0.70); }
    .drop-hint{ border-top: 2px solid rgba(120,200,255,0.55); }

    

    /* =========================================================
       FHD (1920x1080) 収まり優先のコンパクト調整
       - 右カラムの3セクションが1画面に収まりやすいよう高さ/余白を縮小
       ========================================================= */
    @media (min-width: 1200px) and (max-height: 1080px){
      :root{
      --left-reset-h: 96px; /* 左リセット固定高さ */
        --cross-frame-h: clamp(150px, 18vw, 220px);
        --ougi-frame-h:  clamp(150px, 18vw, 220px);
        --marker-row-h: clamp(64px, 6.8vw, 88px);
      --marker-frame-h: var(--marker-row-h);

        --board-size: 360px;
        --kind-icon: clamp(46px, 5.0vw, 64px);
        --kind-pill-minh: var(--marker-row-h);
      }

      .app{ padding: 10px; }
      .layout{ gap: 12px; }
      .stack{ gap: 10px; }

      .section-header{ padding: 8px 10px; }
      .section-body{ padding: 10px; }

      .left-controls{ padding: 12px; }
      .board-wrap{ padding: 12px; }
      .meteor-wrap{ padding: 12px; }
      .reset-wrap{ padding: 12px; align-items:center; }
      .divider{ margin: 10px 12px; }

      .marker-rows{ gap: 10px; }
      .marker-row{ gap: 10px; }
    }
@media (prefers-reduced-motion: reduce){ *{ transition:none !important; } }



  </style>
</head>
<body>
  <div class="app">
    <div class="layout">
      <!-- LEFT -->
      <aside class="panel" aria-label="操作パネル">
        <div class="left-stack" id="leftStack" aria-label="左コントロール（ドラッグで並び替え）">

          <div class="left-unit" data-left-id="crossCtrl">
            <div class="left-handle" title="ドラッグで並び替え" aria-label="ドラッグで並び替え">≡</div>
            <div class="left-controls">
              <div class="btn-col">
                <button class="btn" data-cross="plus">＋字</button>
                <button class="btn" data-cross="x">×字</button>
              </div>


          <div class="left-unit" data-left-id="markerCtrl">
            <div class="left-handle" title="ドラッグで並び替え" aria-label="ドラッグで並び替え">≡</div>
            <div class="board-wrap">
              <div class="board-caption">マーカー（A/B/C/D/1/2/3/4）を押す → 右で大円/頭割を選択</div>
              <div class="marker-board" id="markerBoard">
                <button class="mk square c-pink mk-1" data-marker="1" type="button">1</button>
                <button class="mk circle c-pink mk-A" data-marker="A" type="button">A</button>
                <button class="mk square c-yellow mk-2" data-marker="2" type="button">2</button>

                <button class="mk circle c-purple mk-D" data-marker="D" type="button">D</button>
                <button class="mk circle c-yellow mk-B" data-marker="B" type="button">B</button>

                <button class="mk square c-purple mk-4" data-marker="4" type="button">4</button>
                <button class="mk circle c-blue mk-C" data-marker="C" type="button">C</button>
                <button class="mk square c-blue mk-3" data-marker="3" type="button">3</button>
              </div>


          <div class="left-unit" data-left-id="ougiCtrl">
            <div class="left-handle" title="ドラッグで並び替え" aria-label="ドラッグで並び替え">≡</div>
            <div class="left-controls">
              <div class="btn-col">
                <button class="btn" data-ougi="12">1・2 安地</button>
                <button class="btn" data-ougi="34">3・4 安地</button>
              </div>


          <div class="left-unit" data-left-id="meteorCtrl">
            <div class="left-handle" title="ドラッグで並び替え" aria-label="ドラッグで並び替え">≡</div>
            <div class="meteor-wrap">
              <div class="board-caption">隕石（赤/黄/緑/紫）を選択</div>
              <div class="meteor-strip" id="meteorStrip">
                <button class="meteor-btn" data-meteor="red" type="button" aria-label="赤隕石"><img src="./img/meteor-red.png" alt="赤隕石"></button>
                <button class="meteor-btn" data-meteor="yellow" type="button" aria-label="黄隕石"><img src="./img/meteor-yellow.png" alt="黄隕石"></button>
                <button class="meteor-btn" data-meteor="green" type="button" aria-label="緑隕石"><img src="./img/meteor-green.png" alt="緑隕石"></button>
                <button class="meteor-btn" data-meteor="purple" type="button" aria-label="紫隕石"><img src="./img/meteor-purple.png" alt="紫隕石"></button>
              </div>
              <div style="margin-top:10px; color:var(--muted); font-size:12px;">状態: <span id="markerState">未選択</span></div>
            </div>
          </div>

        </div>

        <div class="reset-wrap">
          <button class="btn btn-reset" id="resetBtn" type="button">リセット</button>
          <div class="reset-hint">※並び替え・非表示は保持</div>
        </div>
      </aside>

      <!-- RIGHT -->
      <main class="stack" id="displayStack" aria-label="表示パネル">
        <div class="layout-bar" id="layoutBar">
          <button class="mode-switch" id="freeLayoutBtn" type="button" role="switch" aria-checked="false" title="結果ウィンドウを自由に配置">
  <span class="mode-label">配置モード</span>
  <span class="mode-state">(OFF)</span>
  <span class="mode-track" aria-hidden="true"><span class="mode-thumb"></span></span>
</button>
          <button class="layout-btn" id="resetLayoutBtn" type="button" title="自由配置の位置をリセット">配置リセット</button>
        </div>

        <!-- SECTION: Cross -->
        <section class="section" data-section-id="marker" data-span="2">
          <div class="section-header">
            <div class="drag-handle" title="ドラッグで並び替え" aria-label="ドラッグで並び替え">≡</div>
            <div class="section-title">マーカー表示（大円 / 頭割）</div>
            <button class="icon-btn" data-action="toggleHide" aria-label="非表示切替">非表示</button>
          </div>
          <div class="section-body">
            <div class="marker-rows" id="markerRows">
              <div class="marker-row" data-kind="aoe" id="rowAoe">
                <button class="kind-pill" data-pick-kind="aoe" type="button">
                  <div class="t">大円</div>
                  <img src="./img/effect_aoe.png" alt="大円" />
                </button>
                <div class="frame marker-frame placeholder" id="aoeFrame" data-placeholder="マーカーを押すとここに表示"></div>
              </div>

              <div class="marker-row" data-kind="share" id="rowShare">
                <button class="kind-pill" data-pick-kind="share" type="button">
                  <div class="t">頭割</div>
                  <img src="./img/effect_share.png" alt="頭割" />
                </button>
                <div class="frame marker-frame placeholder" id="shareFrame" data-placeholder="マーカーを押すとここに表示"></div>
              </div>
            </div>
          </div>
        </section>

<section class="section" data-section-id="ougi" data-span="1">
  <div class="section-header">
    <div class="drag-handle" title="ドラッグで並び替え" aria-label="ドラッグで並び替え">≡</div>
    <div class="section-title">1・2安地 / 3・4安地</div>
    <button class="icon-btn" data-action="toggleHide" aria-label="非表示切替">非表示</button>
  </div>
  <div class="section-body">
    <div class="frame ougi placeholder" id="ougiFrame" data-placeholder="安地を押すとここに表示" style="height: var(--ougi-frame-h);">
      <div class="result-label is-empty" id="ougiLabel"></div>
    </div>
  </div>
</section>

<section class="section" data-section-id="meteorResult" data-span="1">
  <div class="section-header">
    <div class="drag-handle" title="ドラッグで並び替え" aria-label="ドラッグで並び替え">≡</div>
    <div class="section-title">隕石結果</div>
    <button class="icon-btn" data-action="toggleHide" aria-label="非表示切替">非表示</button>
  </div>
  <div class="section-body">
    <div class="frame meteor-frame placeholder" id="meteorFrame" data-placeholder="隕石を選ぶとここに表示" style="height: var(--ougi-frame-h);">
      <div class="meteor-inner">
        <div class="meteor-result-img">
          <img id="meteorResultImg" alt="">
        </div>
        <div class="meteor-text">
          <div class="meteor-title" id="meteorTitle"></div>
          <div class="meteor-lines" id="meteorLines"></div>
        </div>
      </div>
    </div>
  </div>
</section>

        <section class="section" data-section-id="cross" data-span="2">
          <div class="section-header">
            <div class="drag-handle" title="ドラッグで並び替え" aria-label="ドラッグで並び替え">≡</div>
            <div class="section-title">＋字 / ×字</div>
            <button class="icon-btn" data-action="toggleHide" aria-label="非表示切替">非表示</button>
          </div>
          <div class="section-body">
            <div class="frame cross placeholder" id="crossFrame" data-placeholder="十字 / X字を押すとここに表示" style="height: var(--cross-frame-h);">
              <div class="result-label is-empty" id="crossLabel"></div>
            </div>
          </div>
        </section>

  <script>
  /* EDIT HERE（画像パス / 保存キー）
       ========================================================= */
    const CONFIG = {
      storageKeyOrder: 'kanpe_section_order_v3',
      storageKeyHidden: 'kanpe_section_hidden_v2',

      images: {
        cross: {
          plus: './img/jyuuji.png',
          x: './img/Xji.png',
        },
        ougi: {
          '12': './img/ougi_12.png',
          '34': './img/ougi_34.png',
        },
        // marker: ./img/sen_${id}_${kind}.png  (idは小文字 a/b/c/d, 数字はそのまま)
        marker: {
          base: './img/sen_',
          suffix: { aoe: '_aoe.png', share: '_share.png' }
        },
        meteor: {
          red: './img/meteor-red.png',
          yellow: './img/meteor-yellow.png',
          green: './img/meteor-green.png',
          purple: './img/meteor-purple.png'
        }
      },
    };

    const $ = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

    function loadJSON(key, fallback){
      try{ const s = localStorage.getItem(key); return s ? (JSON.parse(s) ?? fallback) : fallback; }
      catch(e){ return fallback; }
    }
    function saveJSON(key, value){ try{ localStorage.setItem(key, JSON.stringify(value)); }catch(e){} }

    function setFrameImage(frameEl, src){
      // Keep label element if present
      const label = frameEl.querySelector('.result-label');
      // Remove existing img only
      const oldImg = frameEl.querySelector('img');
      if(oldImg) oldImg.remove();

      frameEl.classList.remove('placeholder');

      const img = new Image();
      img.alt = '';
      img.decoding = 'async';
      img.loading = 'eager';
      img.src = src;
      img.onerror = () => {
        frameEl.classList.add('placeholder');
        frameEl.dataset.placeholder = `画像が見つかりません: ${src}`;
        const bad = frameEl.querySelector('img');
        if(bad) bad.remove();
      };

      if(label) frameEl.insertBefore(img, label.nextSibling);
      else frameEl.appendChild(img);
    }

    function clearFrame(frameEl, placeholderText){
      const label = frameEl.querySelector('.result-label');
      // remove only images
      frameEl.querySelectorAll('img').forEach(i => i.remove());
      frameEl.classList.add('placeholder');
      frameEl.dataset.placeholder = placeholderText;
      if(label){ label.classList.add('is-empty'); label.textContent=''; }
    }

    /* =========================================================
       Cross / Ougi (仕様：同じボタンを押しても消さない)
       ========================================================= */
    let selectedCross = null; // 'plus'|'x'|null
    let selectedOugi = null;  // '12'|'34'|null

    const crossFrame = $('#crossFrame');
    const ougiFrame  = $('#ougiFrame');
    const crossLabel = $('#crossLabel');
    const ougiLabel  = $('#ougiLabel');

    clearFrame(crossFrame, '十字 / X字を押すとここに表示');
    clearFrame(ougiFrame, '安地を押すとここに表示');

    function setCross(which){
      selectedCross = which;
      // show label = pressed button
      if(crossLabel){ crossLabel.textContent = (which === 'plus' ? '＋字' : '×字'); crossLabel.classList.remove('is-empty'); }
      setFrameImage(crossFrame, CONFIG.images.cross[which]);
      $$('.btn[data-cross]').forEach(btn => btn.classList.toggle('is-active', btn.dataset.cross === which));
    }
    function setOugi(which){
      selectedOugi = which;
      if(ougiLabel){ ougiLabel.textContent = (which === '12' ? '1・2 安地' : '3・4 安地'); ougiLabel.classList.remove('is-empty'); }
      setFrameImage(ougiFrame, CONFIG.images.ougi[which]);
      $$('.btn[data-ougi]').forEach(btn => btn.classList.toggle('is-active', btn.dataset.ougi === which));
    }

    document.addEventListener('click', (e) => {
      const crossBtn = e.target.closest('.btn[data-cross]');
      if(crossBtn){ setCross(crossBtn.dataset.cross); return; }

      const ougiBtn = e.target.closest('.btn[data-ougi]');
      if(ougiBtn){ setOugi(ougiBtn.dataset.ougi); return; }

      const mBtn = e.target.closest('.meteor-btn[data-meteor]');
      if(mBtn){ setMeteor(mBtn.dataset.meteor); return; }
    });

    /* =========================================================
       Meteor logic
       - 左の隕石ボタン → 右に画像 + テキスト表示
       ========================================================= */
    let selectedMeteor = null; // 'red'|'yellow'|'green'|'purple'|null

    const meteorFrame = $('#meteorFrame');
    const meteorImg = $('#meteorResultImg');
    const meteorTitle = $('#meteorTitle');
    const meteorLines = $('#meteorLines');

    const METEOR_INFO = {
      red:    { label: '赤',   img: CONFIG.images.meteor.red,    lines: ['移動禁止', 'ニア／ファー誘導'] },
      yellow: { label: '黄',   img: CONFIG.images.meteor.yellow, lines: ['タケノコ設置', 'ニア／ファー誘導'] },
      green:  { label: '緑',   img: CONFIG.images.meteor.green,  lines: ['ノックアップ', 'ファー'] },
      purple: { label: '紫',   img: CONFIG.images.meteor.purple, lines: ['死の宣告ビーム', 'ニア'] },
    };

    function clearMeteor(){
      selectedMeteor = null;
      if(meteorFrame){
        meteorFrame.classList.add('placeholder');
        meteorFrame.dataset.placeholder = '隕石を選ぶとここに表示';
      }
      if(meteorImg){ meteorImg.removeAttribute('src'); }
      if(meteorTitle){ meteorTitle.textContent=''; }
      if(meteorLines){ meteorLines.textContent=''; }
      $$('.meteor-btn').forEach(b => b.classList.remove('is-active'));
    }

    // init (default: empty)
    clearMeteor();

    function setMeteor(key){
      selectedMeteor = key;
      const info = METEOR_INFO[key];
      if(!info || !meteorFrame) return;

      meteorFrame.classList.remove('placeholder');
      meteorImg.src = info.img;
      meteorTitle.textContent = info.label;
      meteorLines.textContent = info.lines.map(t => `・${t}`).join('\n');

      $$('.meteor-btn').forEach(b => b.classList.toggle('is-active', b.dataset.meteor === key));
    }


    /* =========================================================
       Marker logic
       - マーカー押下: 2種類表示に戻す
       - 大円/頭割を選ぶ: 片方だけ残す（もう片方は透明）
       - 枠サイズは常に一定
       ========================================================= */
    let currentMarker = null; // 'A'.. or '1'..
    let chosenKind = null;    // 'aoe'|'share'|null

    const markerState = $('#markerState');
    const aoeFrame = $('#aoeFrame');
    const shareFrame = $('#shareFrame');

    clearFrame(aoeFrame, 'マーカーを押すとここに表示');
    clearFrame(shareFrame, 'マーカーを押すとここに表示');

    function markerFileId(id){
      return /^[A-D]$/.test(id) ? id.toLowerCase() : id;
    }
    function getMarkerImage(id, kind){
      const fid = markerFileId(id);
      return CONFIG.images.marker.base + fid + CONFIG.images.marker.suffix[kind];
    }

    function setMarker(id){
      currentMarker = id;
      chosenKind = null;

      $$('.mk').forEach(b => b.classList.toggle('is-active', b.dataset.marker === id));
      markerState.textContent = `選択: ${id}`;

      // 2種類とも表示
      setFrameImage(aoeFrame, getMarkerImage(id, 'aoe'));
      setFrameImage(shareFrame, getMarkerImage(id, 'share'));

      $('#rowAoe').classList.remove('is-muted');
      $('#rowShare').classList.remove('is-muted');
      $$('.kind-pill').forEach(b => b.classList.remove('is-on'));
    }

    function pickKind(kind){
      if(!currentMarker) return;
      chosenKind = kind;

      $('#rowAoe').classList.toggle('is-muted', kind !== 'aoe');
      $('#rowShare').classList.toggle('is-muted', kind !== 'share');

      $$('.kind-pill').forEach(b => b.classList.toggle('is-on', b.dataset.pickKind === kind));
    }

    $('#markerBoard').addEventListener('click', (e) => {
      const b = e.target.closest('.mk');
      if(!b) return;
      setMarker(b.dataset.marker);
    });

    document.addEventListener('click', (e) => {
      const pk = e.target.closest('[data-pick-kind]');
      if(pk){ pickKind(pk.dataset.pickKind); return; }

      const frame = e.target.closest('.frame');
      if(frame && (frame.id === 'aoeFrame' || frame.id === 'shareFrame')){
        pickKind(frame.id === 'aoeFrame' ? 'aoe' : 'share');
      }
    });

    /* =========================================================
       Reset button (keeps order/hidden)
       ========================================================= */
    const resetBtn = $("#resetBtn");
    function resetLeftState(){
      // Cross / Ougi
      selectedCross = null;
      selectedOugi = null;
      clearFrame(crossFrame, '十字 / X字を押すとここに表示');
      clearFrame(ougiFrame,  '安地を押すとここに表示');
      $$('.btn[data-cross]').forEach(btn => btn.classList.remove('is-active'));
      $$('.btn[data-ougi]').forEach(btn => btn.classList.remove('is-active'));

      // Meteor
      clearMeteor();

      // Marker
      currentMarker = null;
      chosenKind = null;
      markerState.textContent = '未選択';
      $$('.mk').forEach(b => b.classList.remove('is-active'));
      clearFrame(aoeFrame,   'マーカーを押すとここに表示');
      clearFrame(shareFrame, 'マーカーを押すとここに表示');
      $('#rowAoe').classList.remove('is-muted');
      $('#rowShare').classList.remove('is-muted');
      $$('.kind-pill').forEach(b => b.classList.remove('is-on'));
    }
    if(resetBtn){
      resetBtn.addEventListener('click', resetLeftState);
    }

/* =========================================================
       Hide / Collapse per section
       ========================================================= */
    const displayStack = $('#displayStack');
    const hiddenMap = loadJSON(CONFIG.storageKeyHidden, {});

    function applyHiddenStates(){
      $$('.section', displayStack).forEach(sec => {
        const id = sec.dataset.sectionId;
        const collapsed = !!hiddenMap[id];
        sec.classList.toggle('is-collapsed', collapsed);
        const btn = sec.querySelector('[data-action="toggleHide"]');
        if(btn){ btn.classList.toggle('is-on', collapsed); btn.textContent = collapsed ? '表示' : '非表示'; }
      });
    }

    displayStack.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-action="toggleHide"]');
      if(!btn) return;
      const sec = e.target.closest('.section');
      if(!sec) return;
      const id = sec.dataset.sectionId;
      hiddenMap[id] = !hiddenMap[id];
      saveJSON(CONFIG.storageKeyHidden, hiddenMap);
      applyHiddenStates();
    });

    applyHiddenStates();


/* =========================================================
   Free layout (結果ウィンドウを自由配置)
   - OFF: これまで通り（縦に並ぶ）
   - ON : セクションをドラッグで好きな位置へ（位置を保存）
   ========================================================= */
const freeBtn  = $('#freeLayoutBtn');
const resetPosBtn = $('#resetLayoutBtn');
const POS_KEY = 'kanpe_free_positions_v1';
const Z_KEY = 'kanpe_free_z_v1';
let zCounter = 1000;
function bringToFront(sec){
  // last interacted window should be on top
  zCounter += 1;
  sec.style.zIndex = String(zCounter);
}
const MODE_KEY = 'kanpe_free_mode_v1';

function loadPositions(){
  return loadJSON(POS_KEY, {});
}
function savePositions(pos){
  saveJSON(POS_KEY, pos);
}
function setFreeMode(on){
  const turningOn = on && !displayStack.classList.contains('free-layout');

  // OFFの見た目から開始したいので、ONへ切り替える直前に現在位置を取得
  if(turningOn){
    const pos = loadPositions();

    const secs = $$('.section', displayStack);
    const secIds = secs.map(s=>s.dataset.sectionId);

    function isBadPositions(p){
      // 未保存・欠損
      if(!p || Object.keys(p).length === 0) return true;
      for(const id of secIds){ if(!p[id]) return true; }
      // だいたい全部同じ位置(0,0)などに固まっている
      const first = p[secIds[0]];
      let same = 0;
      for(const id of secIds){
        const q = p[id];
        if(!q) return true;
        const l = Number(q.left||0), t = Number(q.top||0), w = Number(q.width||0);
        if(!isFinite(l) || !isFinite(t) || !isFinite(w) || w < 220) return true;
        if(Math.abs(l - Number(first.left||0)) < 3 && Math.abs(t - Number(first.top||0)) < 3) same++;
      }
      return same >= secIds.length; // 全部ほぼ同じ場所
    }

    if(isBadPositions(pos)){
      const stackRect = displayStack.getBoundingClientRect();
      const flowPos = {};
      secs.forEach(sec=>{
        const id = sec.dataset.sectionId;
        const r = sec.getBoundingClientRect();
        flowPos[id] = {
          left: Math.max(0, r.left - stackRect.left),
          top:  Math.max(0, r.top  - stackRect.top),
          width: r.width,
          z: parseInt(getComputedStyle(sec).zIndex || '0', 10) || 0
        };
      });
      savePositions(flowPos);
    }
  }

  displayStack.classList.toggle('free-layout', on);

  if(freeBtn){
    freeBtn.classList.toggle('is-on', on);
    freeBtn.setAttribute('aria-checked', on ? 'true' : 'false');
    const st = freeBtn.querySelector('.mode-state');
    if(st) st.textContent = on ? '(ON)' : '(OFF)';
  }

  localStorage.setItem(MODE_KEY, on ? '1' : '0');

  if(on){
    applyPositions(loadPositions());
  }else{
    // 解除：inline styleを消して通常レイアウトに戻す（保存は残す）
    $$('.section', displayStack).forEach(sec=>{
      sec.style.left = '';
      sec.style.top = '';
      sec.style.width = '';
      sec.style.zIndex = '';
    });
    displayStack.style.minHeight = '';
    displayStack.style.minWidth = '';
  }
}

function applyPositions(pos){
  const stackRect = displayStack.getBoundingClientRect();
  const viewW = displayStack.clientWidth;
  const maxW = Math.max(viewW, parseFloat(getComputedStyle(displayStack).minWidth) || 0);
  // width bounds
  const minW1 = 320;
  const maxW1 = Math.max(minW1, Math.floor(viewW * 0.55));

  let maxBottom = 0;
  let maxRight = 0;

  $$('.section', displayStack).forEach(sec=>{
    const id = sec.dataset.sectionId;
    const p = pos[id];
    if(!p) return;

    const span = sec.dataset.span || '1';

    // Width rule:
    // - span=2 : keep stored width within bounds
    // - span=1 : use stored width (not forced), to allow horizontal movement
    let w;
    if(span === '2'){
      const cap = Math.max(360, maxW - 40);
      w = Math.min(cap, Math.max(520, p.width || Math.min(920, cap)));
    }else{
      const cap = Math.max(minW1, Math.min(maxW1, maxW - 40));
      w = Math.min(cap, Math.max(minW1, p.width || Math.min(520, cap)));
    }

    const left = Math.max(0, Math.min(maxW - w, (p.left || 0)));
    const top  = Math.max(0, (p.top || 0));

    sec.style.width = w + 'px';
    sec.style.left = left + 'px';
    sec.style.top  = top + 'px';

    // z-index
    if(typeof p.z === 'number'){
      sec.style.zIndex = String(p.z);
      zCounter = Math.max(zCounter, p.z);
    }

    maxBottom = Math.max(maxBottom, top + sec.offsetHeight);
    maxRight = Math.max(maxRight, left + w);
  });

  // Ensure enough drag space vertically
  const baseMin = Math.max(1600, Math.ceil(window.innerHeight * 1.8));
  const need = Math.max(baseMin, Math.ceil(maxBottom + 420));
  displayStack.style.minHeight = need + 'px';
  const baseW = Math.ceil(viewW * 1.6);
  const needW = Math.max(baseW, Math.ceil(maxRight + 420));
  if(needW > viewW){ displayStack.style.minWidth = needW + 'px'; }
}


function resetPositions(){
  // 位置保存を消して、OFF配置を基準に取り直す
  savePositions({});
  // いったん free-layout を外してフロー配置に戻す
  const wasOn = displayStack.classList.contains('free-layout');

  // inline style を消す
  $$('.section', displayStack).forEach(sec=>{
    sec.style.left = '';
    sec.style.top = '';
    sec.style.width = '';
    sec.style.zIndex = '';
  });
  displayStack.style.minHeight = '';
  displayStack.style.minWidth = '';

  if(wasOn){
    displayStack.classList.remove('free-layout');
    // reflow
    void displayStack.offsetHeight;
    // ONへ（turningOn扱いになり、フロー位置を初期座標として保存→適用）
    setFreeMode(true);
  }
}

if(freeBtn){
  freeBtn.addEventListener('click', ()=>{
    const on = !displayStack.classList.contains('free-layout');
    setFreeMode(on);
  });
}
if(resetPosBtn){
  resetPosBtn.addEventListener('click', resetPositions);
}

// 起動時に復元
const savedMode = localStorage.getItem(MODE_KEY) === '1';
if(savedMode){ setFreeMode(true); }

// 画面幅が変わったら、free配置の横はみ出しを補正
window.addEventListener('resize', ()=>{
  if(!displayStack.classList.contains('free-layout')) return;
  applyPositions(loadPositions());
});

    /* =========================================================
       Drag reorder (Pointer Events)
       ========================================================= */
    function applySavedOrder(){
      const order = loadJSON(CONFIG.storageKeyOrder, null);
      if(!order || !Array.isArray(order)) return;
      const sections = new Map($$('.section', displayStack).map(s => [s.dataset.sectionId, s]));
      order.forEach(id => {
        const sec = sections.get(id);
        if(sec) displayStack.appendChild(sec);
      });
    }
    function saveOrder(){
      const order = $$('.section', displayStack).map(s => s.dataset.sectionId);
      saveJSON(CONFIG.storageKeyOrder, order);
    }
    applySavedOrder();
/* =========================================================
   Left panel reorder (Pointer Events)
   ========================================================= */
const leftStack = $('#leftStack');
const LEFT_ORDER_KEY = 'kanpe_left_order_v2';

function applyLeftOrder(){
  if(!leftStack) return;
  const order = loadJSON(LEFT_ORDER_KEY, null);
  if(!order || !Array.isArray(order)) return;
  const units = new Map($$('.left-unit', leftStack).map(u => [u.dataset.leftId, u]));
  order.forEach(id => {
    const u = units.get(id);
    if(u) leftStack.appendChild(u);
  });
}
function saveLeftOrder(){
  if(!leftStack) return;
  const order = $$('.left-unit', leftStack).map(u => u.dataset.leftId);
  saveJSON(LEFT_ORDER_KEY, order);
}
applyLeftOrder();

let ldrag = { active:false, unit:null, pid:null };
function clearLeftHints(){ if(!leftStack) return; $$('.left-unit', leftStack).forEach(u => u.classList.remove('is-drop-hint')); }

if(leftStack){
  leftStack.addEventListener('pointerdown', (e)=>{
    const handle = e.target.closest('.left-handle');
    if(!handle) return;
    const unit = handle.closest('.left-unit');
    if(!unit) return;

    ldrag.active = true;
    ldrag.unit = unit;
    ldrag.pid = e.pointerId;

    unit.classList.add('is-dragging');
    handle.setPointerCapture(e.pointerId);
    e.preventDefault();
  });

  leftStack.addEventListener('pointermove', (e)=>{
    if(!ldrag.active || e.pointerId !== ldrag.pid) return;
    const el = document.elementFromPoint(e.clientX, e.clientY);
    const over = el ? el.closest('.left-unit') : null;
    if(!over || over === ldrag.unit){ clearLeftHints(); return; }

    clearLeftHints();
    over.classList.add('is-drop-hint');

    const r = over.getBoundingClientRect();
    const before = e.clientY < r.top + r.height/2;
    if(before) leftStack.insertBefore(ldrag.unit, over);
    else leftStack.insertBefore(ldrag.unit, over.nextSibling);
  });

  function endLeftDrag(e){
    if(!ldrag.active) return;
    if(e && e.pointerId !== ldrag.pid) return;
    ldrag.active = false;
    clearLeftHints();
    saveLeftOrder();
    ldrag.unit = null;
    ldrag.pid = null;
  }
  leftStack.addEventListener('pointerup', endLeftDrag);
  leftStack.addEventListener('pointercancel', endLeftDrag);
}

    let drag = { active:false, sec:null, pointerId:null };

    function clearDropHints(){ $$('.section', displayStack).forEach(s => s.classList.remove('drop-hint')); }

    displayStack.addEventListener('pointerdown', (e) => {
      if(displayStack.classList.contains('free-layout')){
        // 自由配置モード：並び替えは無効（代わりにドラッグ移動）
        const handle = e.target.closest('.drag-handle');
        if(!handle) return;
        const sec = handle.closest('.section');
        if(!sec) return;
        bringToFront(sec);
        const stackRect = displayStack.getBoundingClientRect();
        const startX = e.clientX; const startY = e.clientY;
        const startLeft = parseFloat(sec.style.left || (sec.getBoundingClientRect().left - stackRect.left));
        const startTop  = parseFloat(sec.style.top  || (sec.getBoundingClientRect().top  - stackRect.top));
        const pid = e.pointerId;
        handle.setPointerCapture(pid);
        e.preventDefault();

        function onMove(ev){
          if(ev.pointerId !== pid) return;
          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          const nl = Math.max(0, startLeft + dx);
          const stagePad = 140;
          const needW = nl + sec.offsetWidth + stagePad;
          const curMinW = parseFloat(getComputedStyle(displayStack).minWidth) || displayStack.clientWidth;
          if(needW > curMinW){
            displayStack.style.minWidth = Math.ceil(needW) + "px";
          }
          const nt = Math.max(0, startTop + dy);
          sec.style.left = nl + 'px';
          sec.style.top  = nt + 'px';

          // expand vertical drag space as needed
          const needed = nt + sec.offsetHeight + 120;
          const curMinH = parseFloat(getComputedStyle(displayStack).minHeight) || displayStack.clientHeight;
          if(needed > curMinH){
            displayStack.style.minHeight = Math.ceil(Math.max(needed, curMinH)) + "px";
          }
        }
        function onUp(ev){
          if(ev.pointerId !== pid) return;
          handle.releasePointerCapture(pid);
          displayStack.removeEventListener('pointermove', onMove);
          displayStack.removeEventListener('pointerup', onUp);
          displayStack.removeEventListener('pointercancel', onUp);
          const pos = loadPositions();
          const r = sec.getBoundingClientRect();
          pos[sec.dataset.sectionId] = {
            left: Math.max(0, r.left - stackRect.left),
            top:  Math.max(0, r.top  - stackRect.top),
            width: r.width,
            z: parseInt(sec.style.zIndex || '0', 10) || 0
          };
          savePositions(pos);
        }
        displayStack.addEventListener('pointermove', onMove);
        displayStack.addEventListener('pointerup', onUp);
        displayStack.addEventListener('pointercancel', onUp);
        return;
      }

      const handle = e.target.closest('.drag-handle');
      if(!handle) return;
      const sec = handle.closest('.section');
      if(!sec) return;

      drag.active = true;
      drag.sec = sec;
      drag.pointerId = e.pointerId;
      sec.classList.add('is-dragging');
      handle.setPointerCapture(e.pointerId);
      e.preventDefault();
    });

    displayStack.addEventListener('pointermove', (e) => {
      if(!drag.active || e.pointerId !== drag.pointerId) return;

      const el = document.elementFromPoint(e.clientX, e.clientY);
      const over = el ? el.closest('.section') : null;
      if(!over || over === drag.sec){ clearDropHints(); return; }

      clearDropHints();
      over.classList.add('drop-hint');

      const r = over.getBoundingClientRect();
      const before = e.clientY < r.top + r.height/2;
      if(before) displayStack.insertBefore(drag.sec, over);
      else displayStack.insertBefore(drag.sec, over.nextSibling);
    });

    function endDrag(){
      if(!drag.active) return;
      drag.active = false;
      if(drag.sec) drag.sec.classList.remove('is-dragging');
      clearDropHints();
      saveOrder();
      drag.sec = null;
      drag.pointerId = null;
    }

    displayStack.addEventListener('pointerup', endDrag);
    displayStack.addEventListener('pointercancel', endDrag);
  </script>
</body>
</html>
